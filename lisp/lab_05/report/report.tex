\documentclass[a4paper,14pt, unknownkeysallowed]{extreport}

\usepackage{cmap} % Улучшенный поиск русских слов в полученном pdf-файле
\usepackage[T2A]{fontenc} % Поддержка русских букв
\usepackage[utf8]{inputenc} % Кодировка utf8
\usepackage[english,russian]{babel} % Языки: русский, английский
\usepackage{enumitem}


\usepackage{threeparttable}

\usepackage[14pt]{extsizes}

\usepackage{caption}
\captionsetup{labelsep=endash}
\captionsetup[figure]{name={Рисунок}}

% \usepackage{ctable}
% \captionsetup[table]{justification=raggedleft,singlelinecheck=off}

\usepackage{amsmath}

\usepackage{geometry}
\geometry{left=30mm}
\geometry{right=10mm}
\geometry{top=20mm}
\geometry{bottom=20mm}

\usepackage{titlesec}
\titleformat{\section}
	{\normalsize\bfseries}
	{\thesection}
	{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{8pt}
\titlespacing*{\section}{\parindent}{*4}{*4}
\titlespacing*{\subsection}{\parindent}{*4}{*4}

\usepackage{setspace}
\onehalfspacing % Полуторный интервал

\frenchspacing
\usepackage{indentfirst} % Красная строка

\usepackage{titlesec}
\titleformat{\chapter}{\LARGE\bfseries}{\thechapter}{20pt}{\LARGE\bfseries}
\titleformat{\section}{\Large\bfseries}{\thesection}{20pt}{\Large\bfseries}

\usepackage{multirow}
\usepackage{listings}
\usepackage{xcolor}

% Для листинга кода:
\lstset{%
	language=Lisp,   					% выбор языка для подсветки	
	basicstyle=\small\sffamily,			% размер и начертание шрифта для подсветки кода
	numbers=left,						% где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,		     		% размер шрифта для номеров строк
	stepnumber=1,						% размер шага между двумя номерами строк
	numbersep=5pt,						% как далеко отстоят номера строк от подсвечиваемого кода
	frame=single,						% рисовать рамку вокруг кода
	tabsize=4,							% размер табуляции по умолчанию равен 4 пробелам
	captionpos=t,						% позиция заголовка вверху [t] или внизу [b]
	breaklines=true,					
	breakatwhitespace=true,				% переносить строки только если есть пробел
	backgroundcolor=\color{white},
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{blue},
	stringstyle=\color{red},
	commentstyle=\color{gray},
	showspaces=false,
    showstringspaces=false
}


\usepackage{pgfplots}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}


\lstset{
	literate=
	{а}{{\selectfont\char224}}1
	{б}{{\selectfont\char225}}1
	{в}{{\selectfont\char226}}1
	{г}{{\selectfont\char227}}1
	{д}{{\selectfont\char228}}1
	{е}{{\selectfont\char229}}1
	{ж}{{\selectfont\char230}}1
	{з}{{\selectfont\char231}}1
	{и}{{\selectfont\char232}}1
	{й}{{\selectfont\char233}}1
	{к}{{\selectfont\char234}}1
	{л}{{\selectfont\char235}}1
	{м}{{\selectfont\char236}}1
	{н}{{\selectfont\char237}}1
	{о}{{\selectfont\char238}}1
	{п}{{\selectfont\char239}}1
	{р}{{\selectfont\char240}}1
	{с}{{\selectfont\char241}}1
	{т}{{\selectfont\char242}}1
	{у}{{\selectfont\char243}}1
	{ф}{{\selectfont\char244}}1
	{х}{{\selectfont\char245}}1
	{ц}{{\selectfont\char246}}1
	{ч}{{\selectfont\char247}}1
	{ш}{{\selectfont\char248}}1
	{щ}{{\selectfont\char249}}1
	{ъ}{{\selectfont\char250}}1
	{ы}{{\selectfont\char251}}1
	{ь}{{\selectfont\char252}}1
	{э}{{\selectfont\char253}}1
	{ю}{{\selectfont\char254}}1
	{я}{{\selectfont\char255}}1
	{А}{{\selectfont\char192}}1
	{Б}{{\selectfont\char193}}1
	{В}{{\selectfont\char194}}1
	{Г}{{\selectfont\char195}}1
	{Д}{{\selectfont\char196}}1
	{Е}{{\selectfont\char197}}1
	{Ж}{{\selectfont\char198}}1
	{З}{{\selectfont\char199}}1
	{И}{{\selectfont\char200}}1
	{Й}{{\selectfont\char201}}1
	{К}{{\selectfont\char202}}1
	{Л}{{\selectfont\char203}}1
	{М}{{\selectfont\char204}}1
	{Н}{{\selectfont\char205}}1
	{О}{{\selectfont\char206}}1
	{П}{{\selectfont\char207}}1
	{Р}{{\selectfont\char208}}1
	{С}{{\selectfont\char209}}1
	{Т}{{\selectfont\char210}}1
	{У}{{\selectfont\char211}}1
	{Ф}{{\selectfont\char212}}1
	{Х}{{\selectfont\char213}}1
	{Ц}{{\selectfont\char214}}1
	{Ч}{{\selectfont\char215}}1
	{Ш}{{\selectfont\char216}}1
	{Щ}{{\selectfont\char217}}1
	{Ъ}{{\selectfont\char218}}1
	{Ы}{{\selectfont\char219}}1
	{Ь}{{\selectfont\char220}}1
	{Э}{{\selectfont\char221}}1
	{Ю}{{\selectfont\char222}}1
	{Я}{{\selectfont\char223}}1
}

\usepackage{graphicx}
\newcommand{\img}[3] {
	\begin{figure}[h!]
		\center{\includegraphics[height=#1]{img/#2}}
		\caption{#3}
		\label{img:#2}
	\end{figure}
}


\usepackage[justification=centering]{caption} % Настройка подписей float объектов

\usepackage[unicode,pdftex]{hyperref} % Ссылки в pdf
\hypersetup{hidelinks}

\usepackage{csvsimple}

\newcommand{\code}[1]{\texttt{#1}}

\usepackage{longtable}

\usepackage{array}
\usepackage{booktabs}
\usepackage{floatrow}

\floatsetup[longtable]{LTcapwidth=table}

% \def\UrlBreaks{\do\/\do-\do\_}

\makeatletter
\renewcommand*\l@chapter[2]{%
  \ifnum \c@tocdepth >\m@ne
    \addpenalty{-\@highpenalty}%
    \vskip 1.0em \@plus\p@
    \setlength\@tempdima{1.5em}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
      \leavevmode \bfseries
      \advance\leftskip\@tempdima
      \hskip -\leftskip
      #1\nobreak\normalfont\leaders\hbox{$\m@th
        \mkern \@dotsep mu\hbox{.}\mkern \@dotsep
        mu$}\hfill\nobreak\hb@xt@\@pnumwidth{\hss #2}\par
      \penalty\@highpenalty
    \endgroup
  \fi}
\makeatother

\begin{document}



\begin{titlepage}
	\newgeometry{pdftex, left=2cm, right=2cm, top=2.5cm, bottom=2.5cm}
	\fontsize{12pt}{12pt}\selectfont
	\noindent \begin{minipage}{0.15\textwidth}
		\includegraphics[width=\linewidth]{img/b_logo.jpg}
	\end{minipage}
	\noindent\begin{minipage}{0.9\textwidth}\centering
		\textbf{Министерство науки и высшего образования Российской Федерации}\\
		\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
		\textbf{«Московский государственный технический университет имени Н. Э.~Баумана}\\
		\textbf{(национальный исследовательский университет)»}\\
		\textbf{(МГТУ им. Н. Э.~Баумана)}
	\end{minipage}
	
	\noindent\rule{18cm}{3pt}
	\newline\newline
	\noindent ФАКУЛЬТЕТ $\underline{\text{«Информатика и системы управления»~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$ \newline\newline
	\noindent КАФЕДРА $\underline{\text{«Программное обеспечение ЭВМ и информационные технологии»~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline\newline\newline\newline\newline\newline
	
	
	\begin{center}
		\noindent\begin{minipage}{1.3\textwidth}\centering
		\Large\textbf{   ~~~ Лабораторная работа №5}\newline
		\textbf{по курсу "Функциональное}\newline
		\textbf{и логическое программирование"}\newline\newline\newline
		\end{minipage}
	\end{center}
	
	\noindent\textbf{Тема} 			$\underline{\text{Использование управляющих структур, работа со списками}}$\newline\newline
	\noindent\textbf{Студент} 		$\underline{\text{Ковалец К. Э.}}$\newline\newline
	\noindent\textbf{Группа} 		$\underline{\text{ИУ7-63Б}}$\newline\newline
	\noindent\textbf{Преподаватели} $\underline{\text{Толпинская Н. Б., Строганов Ю. В.}}$\newline
	
	\begin{center}
		\vfill
		Москва~---~\the\year
		~г.
	\end{center}
	\restoregeometry
\end{titlepage}



\setcounter{page}{2}
\chapter{Практические задания}

\section{Задание 1}

Написать функцию, которая по своему списку-аргументу $lst$ определяет является ли он палиндромом (то есть равны ли $lst$ и ($reverse \ lst$)).

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:parallel_processing,caption=Решение задания 1]
(defun compare (lst1 lst2)
    (cond 
        ((null lst1)
            T)
        ((equal (car lst1) (car lst2)) 
            (compare (cdr lst1) (cdr lst2)))
        (T NIL)
    )
)

(defun palindrome (lst)
    (compare lst (reverse lst)))

;; (palindrome '(1 2 3 2 1)) -> T
;; (palindrome '(1 2 3 2)) -> NIL
\end{lstlisting}
\end{center}

\clearpage

\section{Задание 2}

Написать предикат \texttt{set-equal}, который возвращает $t$, если два его множества-аргумента содержат одни и те же элементы, порядок которых не имеет значения.

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:parallel_processing,caption=Решение задания 2]
(defun elem-in-set (elem set)
    (cond 
        ((null set)
            NIL)
        ((equal elem (car set)) 
            T)
        (T
            (elem-in-set elem (cdr set)))
    )
)

(defun check-set-equal (set1 set2)
    (cond 
        ((null set1)
            T)
        ((elem-in-set (car set1) set2) 
            (check-set-equal (cdr set1) set2))
        (T NIL)
    )
)

(defun set-equal (set1 set2)
    (if (equal (length set1) (length set2))
        (check-set-equal set1 set2)
        NIL
    )
)

;;(SET-EQUAL '(1 2 3 4 5) '(4 2 5 1 3)) -> T
;;(SET-EQUAL '(1 2 3 4 5) '(4 2 5 1 7)) -> NIL
\end{lstlisting}
\end{center}

\clearpage

\section{Задание 3}

Напишите свои необходимые функции, которые обрабатывают таблицу из 4-х точечных пар: (страна . столица), и возвращают по стране -- столицу, а по столице -- страну .

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:parallel_processing,caption=Решение задания 3]
(defun find-capital (country table) 
    (cond 
        ((null table) 
            Nil)
        ((eq country (caar table)) 
            (cdar table)) 
        (T 
            (find-capital country (cdr table)))
    )
)

(defun find-country (capital table) 
    (cond 
        ((null table) 
            Nil)
        ((eq capital (cdar table)) 
            (caar table)) 
        (T 
            (find-country capital (cdr table)))
    )
)

;; (find-capital
;;     'Russia
;;     '((USA . Washington)
;;       (Russia . Moscow)
;;       (Germany . Berlin)))
;; -> MOSCOW

;; (find-country
;;     'Moscow
;;     '((USA . Washington)
;;       (Russia . Moscow)
;;       (Germany . Berlin)))
;; -> RUSSIA
\end{lstlisting}
\end{center}

\section{Задание4}

Напишите функцию \texttt{swap-first-last}, которая переставляет в списке-аргументе первый и последний элементы.

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:parallel_processing,caption=Решение задания 4]
(defun swap-first-last (lst)
    (append (last lst) 
            (reverse (cdr (reverse (cdr lst))))
            (list (car lst))
    )
) 

;; (SWAP-FIRST-LAST '(1 2 3 4 5)) -> (5 2 3 4 1)

\end{lstlisting}
\end{center}

\section{Задание 5}

Напишите функцию \texttt{swap-two-ellement}, которая переставляет в списке-аргументе два указанных своими порядковыми номерами элемента в этом списке.

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:parallel_processing,caption=Решение задания 5]
(defun get-elem (lst i)
    (cond
        ((null lst)
            NIL)
        ((equal i 0)
            (car lst))
        (T 
            (get-elem (cdr lst) (- i 1)))
    )
)

(defun set-elem (lst elem i)
    (cond
        ((null lst)
            NIL)
        ((equal i 0)
            (setf (car lst) elem))
        (T 
            (set-elem (cdr lst) elem (- i 1)))
    )
)

(defun swap-two-ellement (lst i j)
    (let* ((tmp_elem (get-elem lst i)))
        (set-elem lst (get-elem lst j) i)
        (set-elem lst tmp_elem j)
        lst
    )
)

;;(SWAP-TWO-ELLEMENT '(1 2 3 4 5) 1 4) -> (1 5 3 4 2)
\end{lstlisting}
\end{center}

\section{Задание 6}

Напишите две функции, \texttt{swap-to-left} и \texttt{swap-to-right}, которые производят одну круговую перестановку в списке-аргументе влево и вправо, соответственно.

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:parallel_processing,caption=Решение задания 6]
(defun swap-to-left (lst)
    (append (cdr lst) (list (car lst))))

;; (SWAP-TO-LEFT '(1 2 3 4)) -> (2 3 4 1)

(defun swap-to-right (lst)
    (append (last lst) (reverse (cdr (reverse lst)))))

;; (SWAP-TO-RIGHT '(1 2 3 4)) -> (4 1 2 3)
\end{lstlisting}
\end{center}

\clearpage

\section{Задание 7}

Напишите функцию, которая добавляет к множеству двухэлементных списков новый двухэлементный список, если его там нет.

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:parallel_processing,caption=Решение задания 7]
(defun check-set-equal (set1 set2)
    (cond 
        ((null set1)
            T)
        ((equal (car set1) (car set2)) 
            (check-set-equal (cdr set1) (cdr set2)))
        (T 
            NIL)
    )
)

(defun set-equal (set1 set2)
    (if (equal (length set1) (length set2))
        (check-set-equal set1 set2)
        NIL
    )
)

(defun is-sublist (lst sublist)
    (cond 
        ((null lst)
            NIL)
        ((set-equal (car lst) sublist) 
            T)
        (T 
            (is-sublist (cdr lst) sublist))
    )
)

(defun add-list (lst new_lst)
    (if (is-sublist lst new_lst)
        lst
        (append lst (list new_lst))
    )
)

;; (ADD-LIST '((1 2) (3 4) (1 1)) '(5 5)) -> ((1 2) (3 4) (1 1) (5 5))
;; (ADD-LIST '((1 2) (3 4) (1 1)) '(1 1)) -> ((1 2) (3 4) (1 1))
\end{lstlisting}
\end{center}

\section{Задание 8}

Напишите функцию, которая умножает на заданное число-аргумент первый числовой элемент списка из заданного 3-х элементного списка-аргумента, когда a) все элементы списка -- числа, b) элементы списка -- любые объекты.

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:parallel_processing,caption=Решение задания 8]
;; a) все элементы списка -- числа
(defun mult-first-num-arg (lst num)
	(setf (car lst) (* (car lst) num))
	lst
)

;; (MULT-FIRST-NUM-ARG '(1 2 3 4) 5) -> (5 2 3 4)

;; b) элементы списка -- любые объекты
(defun mult-first-num-arg (lst num)
	(cond 
		((null lst)
			NIL)
		((numberp (car lst)) 
			(setf (car lst) (* (car lst) num)))
		(T 
			(mult-first-num-arg (cdr lst) num))
	)
	lst
)

;; (MULT-FIRST-NUM-ARG '(a (1 2) 3 4) 5) -> (A (1 2) 15 4)
;; (MULT-FIRST-NUM-ARG '(a (1 2)) 5) -> (A (1 2))
\end{lstlisting}
\end{center}

\clearpage

\section{Задание 9}

Напишите функцию, \texttt{select-between}, которая из списка-аргумента из 5 чисел выбирает только те, которые расположены между двумя указанными границами-аргументами и возвращает их в виде списка (упорядоченного по возрастанию чисел списка (+ 2 балла)).

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:parallel_processing,caption=Решение задания 9]
(defun find-right-numbers (res_lst lst b1 b2)
    (let* ((cur_elem (car lst)))
        (cond
            ((null lst)
                res_lst)
            ((and (numberp cur_elem) 
                    (> cur_elem b1)
                    (< cur_elem b2))
                (find-right-numbers 
                    (append res_lst (list cur_elem))
                    (cdr lst) b1 b2))
            (T 
                (find-right-numbers res_lst (cdr lst) b1 b2))
        )
    )
)

(defun select-between (lst b1 b2)
    (let* ((res_lst ()))
        (sort (find-right-numbers res_lst lst b1 b2) #'<)
    )
)

;; (SELECT-BETWEEN '(1 5 4 2 3) 2 5) -> (3 4)
;; (SELECT-BETWEEN '(1 5 4 2 3) 0 6) -> (1 2 3 4 5)
;; (SELECT-BETWEEN '(1 5 4 2 3) 7 9) -> NIL
\end{lstlisting}
\end{center}


\chapter{Ответы на теоретические вопросы к лабораторной работе}

\section{Cтруктурноразрушающие и не разрушающие структуру списка функции}

\subsection{Не разрушающие структуру функции}

Данные функции не меняют сам объект-аргумент, а создают копию. Если после использования функции сохраняется возможность работать с исходным списком, то значит функция не разрушает структуру.

\begin{itemize}
	\item \textbf{append} -- объединяет списки. Можно передать больше двух аргументов. Создает копию для всех аргументов, кроме последнего;
	\item \textbf{reverse} -- возвращает копию исходного списка, элементы которого переставлены в обратном порядке. В целях эффективности работает только на верхнем уровне;
	\item \textbf{remove} -- данная функция удаляет элемент по значению. По умолчанию используется $eql$ для сравнения на равенство, но можно передать другую функцию через ключевой параметр $test$. Модифицирует список, но работает с копией, поэтому не разрушает структуру;
	\item \textbf{rplace} -- переставляет $car$-указатель на второй элемент-аргумент (S-выражение);
	\item \textbf{rplacd} -- переставляет $cdr$-указатель на второй элемент-аргумент (S-выражение);
	\item \textbf{subst} -- заменяет все элементы списка, которые равны второму переданному элементу-аргументу на первый элемент аргумент. По умолчанию для сравнения используется функция $eql$.
\end{itemize}

\subsection{Структуроразрушающие функции}

Данные функции меняют сам объект-аргумент, невозможно вернуться к исходному списку. Чаще всего такие функции начинаются с префикса $n$. Если после использования функции теряется возможность работы с тем списком, который был изначально, то значит его структура разрушилась.

\begin{itemize}
	\item \textbf{nconc} -- работает аналогично функции $append$, только копирует не свои аргументы, а разрушает структуру;
	\item \textbf{nreverse} -- работает аналогично функции $reverse$, только не создает копии списка;
	\item \textbf{nsubst} -- работает аналогично функции $subst$, только не создает копии списка.
\end{itemize}

\section{Отличие в работе функций cons, list, append, nconc и их результаты}

\begin{itemize}
	\item \textbf{cons} -- имеет фиксированное количество аргументов (два). В случае, когда аргументами являются атомы создает точечную пару. В случает, когда первый аргумент атом а второй список, атом становится головой, а второй аргумент (список) становится хвостом;
	\item \textbf{list} -- не имеет фиксированное количество аргументов. Создает список, у которого голова -- это первый аргумент, хвост -- все остальные аргументы. Результат всегда список;
	\item \textbf{append} -- принимает на вход произвольное количество аргументов и для всех аргументов, кроме последнего создает копию, ссылая при этом последний элемент каждого списка-аргумента на первый элемент следующего по порядку списка-аргумента (так как модифицируются все списки-аргументы, кроме последнего, копирование для последнего не делается в целях эффективности);
	\item \textbf{nconc} -- работает как функция $append$, но строит такой результат следующим образом: для каждого непустого аргумента-списка, nconc устанавливает в $cdr$ его последней $cons$-ячейки ссылку на первую $cons$-ячейку следующего непустого аргумента-списка. После этого она возвращает первый список, который теперь является головой результата. Главное отличие от функции $append$ заключается в том, что функция $nconc$ разрушает структуру списка.
\end{itemize}

\end{document}
